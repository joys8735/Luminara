/**\n * Error Handler Service\n * Manages error handling, logging, and retry logic\n * \n * Validates: Requirements 8.1, 8.2, 8.3, 8.4, 8.5, 8.6\n */\n\nimport { ErrorCode, ErrorResponse } from '../types';\nimport { generateOperationId, getCurrentTimestamp } from '../utils';\nimport { SYNC_RETRY_DELAYS, CIRCUIT_BREAKER_THRESHOLD } from '../constants';\n\nexport interface ErrorContext {\n  userId?: string;\n  operationType?: string;\n  pointsType?: string;\n  amount?: number;\n  [key: string]: any;\n}\n\nexport class ErrorHandler {\n  private errorLog: Array<{\n    operationId: string;\n    code: ErrorCode;\n    message: string;\n    context: ErrorContext;\n    timestamp: string;\n  }> = [];\n\n  private failureCount: Map<string, number> = new Map();\n  private circuitBreakerOpen: Map<string, boolean> = new Map();\n  private circuitBreakerTimeout: Map<string, number> = new Map();\n\n  /**\n   * Create error response\n   * Requirement 8.1, 8.3: Log error with context and specific error code\n   */\n  createErrorResponse(\n    code: ErrorCode,\n    message: string,\n    context?: ErrorContext\n  ): ErrorResponse {\n    const operationId = generateOperationId();\n    const timestamp = getCurrentTimestamp();\n\n    // Log error\n    this.errorLog.push({\n      operationId,\n      code,\n      message,\n      context: context || {},\n      timestamp,\n    });\n\n    return {\n      success: false,\n      error: {\n        code,\n        message,\n        operationId,\n        timestamp,\n        context,\n      },\n    };\n  }\n\n  /**\n   * Handle network error\n   * Requirement 8.2: Queue operation and retry with exponential backoff\n   */\n  async handleNetworkError<T>(\n    fn: () => Promise<T>,\n    context?: ErrorContext,\n    maxRetries: number = SYNC_RETRY_DELAYS.length\n  ): Promise<{ success: boolean; data?: T; error?: ErrorResponse }> {\n    let lastError: Error | null = null;\n\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n      try {\n        const data = await fn();\n        return { success: true, data };\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error));\n\n        if (attempt < maxRetries) {\n          const delay = SYNC_RETRY_DELAYS[attempt];\n          await new Promise((resolve) => setTimeout(resolve, delay));\n        }\n      }\n    }\n\n    return {\n      success: false,\n      error: this.createErrorResponse(ErrorCode.NETWORK_ERROR, lastError?.message || 'Network error', context),\n    };\n  }\n\n  /**\n   * Handle validation error\n   * Requirement 8.3: Return specific error code\n   */\n  handleValidationError(message: string, context?: ErrorContext): ErrorResponse {\n    return this.createErrorResponse(ErrorCode.VALIDATION_ERROR, message, context);\n  }\n\n  /**\n   * Handle insufficient balance error\n   */\n  handleInsufficientBalance(context?: ErrorContext): ErrorResponse {\n    return this.createErrorResponse(ErrorCode.INSUFFICIENT_BALANCE, 'Insufficient balance for this operation', context);\n  }\n\n  /**\n   * Handle invalid amount error\n   */\n  handleInvalidAmount(context?: ErrorContext): ErrorResponse {\n    return this.createErrorResponse(ErrorCode.INVALID_AMOUNT, 'Amount must be greater than 0', context);\n  }\n\n  /**\n   * Handle user not found error\n   */\n  handleUserNotFound(context?: ErrorContext): ErrorResponse {\n    return this.createErrorResponse(ErrorCode.USER_NOT_FOUND, 'User not found', context);\n  }\n\n  /**\n   * Handle invalid points type error\n   */\n  handleInvalidPointsType(context?: ErrorContext): ErrorResponse {\n    return this.createErrorResponse(ErrorCode.INVALID_POINTS_TYPE, 'Invalid points type', context);\n  }\n\n  /**\n   * Handle sync error\n   * Requirement 8.2: Implement circuit breaker pattern\n   */\n  handleSyncError(userId: string, message: string, context?: ErrorContext): ErrorResponse {\n    // Increment failure count\n    const failureCount = (this.failureCount.get(userId) || 0) + 1;\n    this.failureCount.set(userId, failureCount);\n\n    // Check circuit breaker\n    if (failureCount >= CIRCUIT_BREAKER_THRESHOLD) {\n      this.circuitBreakerOpen.set(userId, true);\n      this.circuitBreakerTimeout.set(userId, Date.now() + 60000); // 60 second timeout\n    }\n\n    return this.createErrorResponse(ErrorCode.SYNC_FAILED, message, context);\n  }\n\n  /**\n   * Check if circuit breaker is open\n   * Requirement 8.6: Implement circuit breaker pattern\n   */\n  isCircuitBreakerOpen(userId: string): boolean {\n    const isOpen = this.circuitBreakerOpen.get(userId) || false;\n    if (!isOpen) {\n      return false;\n    }\n\n    // Check if timeout expired\n    const timeout = this.circuitBreakerTimeout.get(userId);\n    if (timeout && Date.now() > timeout) {\n      this.circuitBreakerOpen.set(userId, false);\n      this.failureCount.delete(userId);\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Reset circuit breaker\n   */\n  resetCircuitBreaker(userId: string): void {\n    this.circuitBreakerOpen.delete(userId);\n    this.circuitBreakerTimeout.delete(userId);\n    this.failureCount.delete(userId);\n  }\n\n  /**\n   * Get error log\n   * Requirement 8.1: Log error with context\n   */\n  getErrorLog(limit?: number) {\n    let log = [...this.errorLog];\n    if (limit) {\n      log = log.slice(-limit);\n    }\n    return log;\n  }\n\n  /**\n   * Get errors for user\n   */\n  getErrorsForUser(userId: string, limit?: number) {\n    let errors = this.errorLog.filter((e) => e.context.userId === userId);\n    if (limit) {\n      errors = errors.slice(-limit);\n    }\n    return errors;\n  }\n\n  /**\n   * Get errors by code\n   */\n  getErrorsByCode(code: ErrorCode, limit?: number) {\n    let errors = this.errorLog.filter((e) => e.code === code);\n    if (limit) {\n      errors = errors.slice(-limit);\n    }\n    return errors;\n  }\n\n  /**\n   * Clear error log\n   */\n  clearErrorLog(): void {\n    this.errorLog = [];\n  }\n\n  /**\n   * Get failure count for user\n   */\n  getFailureCount(userId: string): number {\n    return this.failureCount.get(userId) || 0;\n  }\n\n  /**\n   * Get error statistics\n   */\n  getStatistics(): {\n    totalErrors: number;\n    errorsByCode: Record<string, number>;\n    recentErrors: number;\n  } {\n    const errorsByCode: Record<string, number> = {};\n    const oneHourAgo = Date.now() - 3600000;\n    let recentErrors = 0;\n\n    this.errorLog.forEach((error) => {\n      errorsByCode[error.code] = (errorsByCode[error.code] || 0) + 1;\n\n      if (new Date(error.timestamp).getTime() > oneHourAgo) {\n        recentErrors++;\n      }\n    });\n\n    return {\n      totalErrors: this.errorLog.length,\n      errorsByCode,\n      recentErrors,\n    };\n  }\n}\n\n// Export singleton instance\nexport const errorHandler = new ErrorHandler();\n