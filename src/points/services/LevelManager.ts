/**\n * Level Manager Service\n * Manages level calculation and progression\n * \n * Validates: Requirements 4.4, 4.5, 4.6\n */\n\nimport { UserLevel, UserLevelData } from '../types';\nimport { LEVEL_THRESHOLDS } from '../constants';\nimport { calculateLevel, checkLevelThreshold } from '../utils';\n\nexport class LevelManager {\n  private userLevels: Map<string, UserLevelData> = new Map();\n  private levelUpBonusPoints = 100; // Requirement 4.6: 100 points per level\n\n  /**\n   * Calculate level based on total points\n   * Requirement 4.4: Calculate level based on thresholds\n   */\n  calculateLevel(totalPoints: number): UserLevel {\n    return calculateLevel(totalPoints);\n  }\n\n  /**\n   * Get level thresholds\n   */\n  getLevelThresholds() {\n    return LEVEL_THRESHOLDS;\n  }\n\n  /**\n   * Get user level\n   */\n  getUserLevel(userId: string): UserLevelData | null {\n    return this.userLevels.get(userId) || null;\n  }\n\n  /**\n   * Initialize user level\n   */\n  initializeUserLevel(userId: string, totalPoints: number): UserLevelData {\n    const currentLevel = this.calculateLevel(totalPoints);\n    const levelData: UserLevelData = {\n      userId,\n      currentLevel,\n      totalPoints,\n      lastLevelUpAt: undefined,\n    };\n\n    this.userLevels.set(userId, levelData);\n    return levelData;\n  }\n\n  /**\n   * Check for level up\n   * Requirement 4.5: Recalculate level on points change\n   * Requirement 4.6: Award 100 bonus points on level up\n   */\n  checkLevelUp(\n    userId: string,\n    newTotalPoints: number\n  ): {\n    leveledUp: boolean;\n    oldLevel?: UserLevel;\n    newLevel?: UserLevel;\n    bonusPoints?: number;\n  } {\n    let levelData = this.userLevels.get(userId);\n\n    if (!levelData) {\n      levelData = this.initializeUserLevel(userId, newTotalPoints);\n    }\n\n    const oldLevel = levelData.currentLevel;\n    const oldPoints = levelData.totalPoints;\n\n    // Check if level changed\n    const { leveledUp, newLevel } = checkLevelThreshold(oldPoints, newTotalPoints);\n\n    if (leveledUp && newLevel) {\n      // Update level data\n      levelData.currentLevel = newLevel;\n      levelData.totalPoints = newTotalPoints;\n      levelData.lastLevelUpAt = new Date().toISOString();\n      this.userLevels.set(userId, levelData);\n\n      return {\n        leveledUp: true,\n        oldLevel,\n        newLevel,\n        bonusPoints: this.levelUpBonusPoints,\n      };\n    } else {\n      // Just update total points\n      levelData.totalPoints = newTotalPoints;\n      this.userLevels.set(userId, levelData);\n\n      return {\n        leveledUp: false,\n      };\n    }\n  }\n\n  /**\n   * Get level info\n   */\n  getLevelInfo(level: UserLevel) {\n    return LEVEL_THRESHOLDS.find((t) => t.level === level);\n  }\n\n  /**\n   * Get points needed for next level\n   */\n  getPointsNeededForNextLevel(totalPoints: number): number {\n    const currentLevel = this.calculateLevel(totalPoints);\n    const currentThreshold = LEVEL_THRESHOLDS.find((t) => t.level === currentLevel);\n\n    if (!currentThreshold) {\n      return 0;\n    }\n\n    // Find next level\n    const nextLevelIndex = LEVEL_THRESHOLDS.findIndex((t) => t.level === currentLevel) + 1;\n    if (nextLevelIndex >= LEVEL_THRESHOLDS.length) {\n      return 0; // Already at max level\n    }\n\n    const nextThreshold = LEVEL_THRESHOLDS[nextLevelIndex];\n    return Math.max(0, nextThreshold.minPoints - totalPoints);\n  }\n\n  /**\n   * Get progress to next level\n   */\n  getProgressToNextLevel(totalPoints: number): {\n    currentLevel: UserLevel;\n    nextLevel: UserLevel | null;\n    currentLevelMinPoints: number;\n    nextLevelMinPoints: number;\n    pointsInCurrentLevel: number;\n    pointsNeededForNextLevel: number;\n    progressPercentage: number;\n  } {\n    const currentLevel = this.calculateLevel(totalPoints);\n    const currentThreshold = LEVEL_THRESHOLDS.find((t) => t.level === currentLevel)!;\n    const currentLevelIndex = LEVEL_THRESHOLDS.findIndex((t) => t.level === currentLevel);\n\n    let nextLevel: UserLevel | null = null;\n    let nextLevelMinPoints = Infinity;\n\n    if (currentLevelIndex < LEVEL_THRESHOLDS.length - 1) {\n      nextLevel = LEVEL_THRESHOLDS[currentLevelIndex + 1].level;\n      nextLevelMinPoints = LEVEL_THRESHOLDS[currentLevelIndex + 1].minPoints;\n    }\n\n    const pointsInCurrentLevel = totalPoints - currentThreshold.minPoints;\n    const pointsNeededForNextLevel = nextLevelMinPoints === Infinity ? 0 : nextLevelMinPoints - totalPoints;\n    const levelRange = nextLevelMinPoints === Infinity ? 1 : nextLevelMinPoints - currentThreshold.minPoints;\n    const progressPercentage = nextLevelMinPoints === Infinity ? 100 : (pointsInCurrentLevel / levelRange) * 100;\n\n    return {\n      currentLevel,\n      nextLevel,\n      currentLevelMinPoints: currentThreshold.minPoints,\n      nextLevelMinPoints: nextLevelMinPoints === Infinity ? 0 : nextLevelMinPoints,\n      pointsInCurrentLevel,\n      pointsNeededForNextLevel,\n      progressPercentage: Math.min(100, Math.max(0, progressPercentage)),\n    };\n  }\n\n  /**\n   * Get all users at specific level\n   */\n  getUsersAtLevel(level: UserLevel): string[] {\n    const users: string[] = [];\n    this.userLevels.forEach((levelData, userId) => {\n      if (levelData.currentLevel === level) {\n        users.push(userId);\n      }\n    });\n    return users;\n  }\n\n  /**\n   * Get level statistics\n   */\n  getLevelStatistics(): {\n    Bronze: number;\n    Silver: number;\n    Gold: number;\n    totalUsers: number;\n  } {\n    const stats = {\n      Bronze: 0,\n      Silver: 0,\n      Gold: 0,\n      totalUsers: this.userLevels.size,\n    };\n\n    this.userLevels.forEach((levelData) => {\n      stats[levelData.currentLevel]++;\n    });\n\n    return stats;\n  }\n\n  /**\n   * Clear user level (for testing)\n   */\n  clearUserLevel(userId: string): void {\n    this.userLevels.delete(userId);\n  }\n\n  /**\n   * Clear all levels (for testing)\n   */\n  clearAll(): void {\n    this.userLevels.clear();\n  }\n}\n\n// Export singleton instance\nexport const levelManager = new LevelManager();\n